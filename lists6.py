a = (1, [2, 3], 4)
print(type(a))   # <type 'tuple'>
b = {a: 1}       # TypeError: unhashable type: 'list'
#-----------------------------------------------
a = {}
print(type(a))     # <class 'dict'>

b = {1, 2, 3}   
print(type(b))     # <class 'set'>

c = {'a': 1, 'b': 2}
print(type(c))     # <class 'dict'>
#-----------------------------------------------
# Зададим исходно список и словарь (скопировать перед примерами ниже):
my_list = ['a', 'b', 'c', 'd', 'e', 'f']
my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
print(my_list)   # ['a', 'b', 'c', 'd', 'e', 'f']
print(my_dict)   # {'a': 1, 'c': 3, 'e': 5, 'f': 6, 'b': 2, 'd': 4}
                 # Не забываем, что порядок элементов в неиндексированных коллекциях не сохраняется.
#-----------------------------------------------
print(len(my_list)) # 6
print(len(my_dict)) # 6 - для словаря пара ключ-значение считаются одним элементом. 
print(len('ab c')) # 4 - для строки элементом является 1 символ

#-----------------------------------------------
my_list = ['a', 'b', 'c', 'd', 'e', 'f']
print('a' in my_list)           # True
print('q' in my_list)           # False
print('a' not in my_list)       # False
print('q' not in my_list)       # True
#-----------------------------------------------
my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
print('a' in my_dict)               # True - без указания метода поиск по ключам
print('a' in my_dict.keys())        # True - аналогично примеру выше
print('a' in my_dict.values())      # False - так как 'а' — ключ, не значение
print(1 in my_dict.values())        # True
#-----------------------------------------------
print(('a',1) in my_dict.items())   # True
print(('a',2) in my_dict.items())   # False
#-----------------------------------------------
#Для строки можно искать не только один символ, но и подстроку:

print('ab' in 'abc')    # True
#-----------------------------------------------
for elm in my_dict:
     	# При таком обходе словаря, перебираются только ключи
	# равносильно for elm in my_dict.keys()
     	print(elm)

 for elm in my_dict.values():
     	# При желании можно пройти только по значениям
     	print(elm)

#Но чаще всего нужны пары ключ(key) — значение (value).

for key, value in my_dict.items():
	# Проход по .items() возвращает кортеж (ключ, значение), 
	# который присваивается кортежу переменных key, value
	print(key, value)
#-----------------------------------------------
#Возможная ошибка: Не меняйте количество элементов коллекции в теле цикла во время итерации по этой же коллекции! — 
#Это порождает не всегда очевидные на первый взгляд ошибки.
#Чтобы этого избежать подобных побочных эффектов, можно, например, итерировать копию коллекции:

for elm in list(my_list):
    	# Теперь можете удалять и добавлять элементы в исходный список my_list,
    	# так как итерация идет по его копии.
#-----------------------------------------------
print(min(my_list))               # a
print(sum(my_dict.values()))      # 21
#-----------------------------------------------
my_list = [1, 2, 2, 2, 2, 3]
print(my_list.count(2))     # 4 экземпляра элемента равного 2
print(my_list.count(5))     # 0 - то есть такого элемента в коллекции нет
#-----------------------------------------------
my_list = [1, 2, 2, 2, 2, 3]
print(my_list.index(2))  # первый элемент равный 2 находится по индексу 1 (индексация с нуля!)
print(my_list.index(5))  # ValueError: 5 is not in list - отсутствующий элемент выдаст ошибку!
#-----------------------------------------------
my_set = {1, 2, 3}
my_set_2 = my_set.copy()
print(my_set_2 == my_set)  # True - коллекции равны - содержат одинаковые значения
print(my_set_2 is my_set)  # False - коллекции не идентичны - это разные объекты с разными id

#-----------------------------------------------
my_set = {1, 2, 3}
print(my_set)  # {1, 2, 3}
my_set.clear()
print(my_set)  # set()
#-----------------------------------------------
set_a = {1, 2, 3}              
set_b = {2, 1}                  # порядок элементов не важен!
set_c = {4}
set_d = {1, 2, 3}

print(set_a.isdisjoint(set_c))  # True - нет общих элементов
print(set_b.issubset(set_a))    # True  - set_b целиком входит в set_a, значит set_b - подмножество
print(set_a.issuperset(set_b))  # True - set_b целиком входит в set_a, значит set_a - надмножество
#-----------------------------------------------
my_tuple = ('a', 'b', 'a')
my_list = list(my_tuple)
my_set = set(my_tuple)		        # теряем индексы и дубликаты элементов!
my_frozenset = frozenset(my_tuple)      # теряем индексы и дубликаты элементов!
print(my_list, my_set, my_frozenset)    # ['a', 'b', 'a'] {'a', 'b'} frozenset({'a', 'b'})
#-----------------------------------------------
my_keys = ('a', 'b', 'c')
my_values = [1, 2]      # Если количество элементов разное - 
		        # будет отработано пока хватает на пары - лишние отброшены
my_dict = dict(zip(my_keys, my_values))
print(my_dict)         # {'a': 1, 'b': 2}
#-----------------------------------------------
my_tuple = ('a', 'b', 'c')
my_str = ''.join(my_tuple)
print(my_str)       # abc
#-----------------------------------------------
my_list = [1, [2, 3], 4]
my_set = set(my_list)   # TypeError: unhashable type: 'list'

#-----------------------------------------------
my_2lvl_list = [[1, 2, 3], ['a', 'b', 'c']]
print(my_2lvl_list[0])      # [1, 2, 3] - первый элемент — первый вложенный список
print(my_2lvl_list[0][0])   # 1 — первый элемент первого вложенного списка
print(my_2lvl_list[1][-1])  # с — последний элемент второго вложенного списка
#-----------------------------------------------
my_list = [1, 2, 3, [4, 5]]
my_list[0] = 10
my_list[-1][0] = 40
print(my_list)      	# [10, 2, 3, [40, 5]]

#Примечание: Для такого присвоения, элемент уже должен существовать в списке, нельзя таким образом добавить элемент на несуществующий индекс.
my_list = [1, 2, 3, 4, 5]
my_list[5] = 6      # IndexError: list assignment index out of range
#-----------------------------------------------
person = ('Alex', 'Smith', "May", 10, 1980)
NAME, BIRTHDAY = slice(None, 2), slice(2, None)       
	# задаем константам именованные срезы
        # данные константы в квадратных скобках заменятся соответствующими срезами
print(person[NAME])      # ('Alex', 'Smith')
print(person[BIRTHDAY])  # ('May', 10, 1980)

my_list = [1, 2, 3, 4, 5, 6, 7]
EVEN = slice(1, None, 2)
print(my_list[EVEN])     # [2, 4, 6]
#-----------------------------------------------
my_list = [1, 2, 3, 4, 5]
# my_list[1:2] = 20     # TypeError: can only assign an iterable
my_list[1:2] = [20]     # Вот теперь все работает
print(my_list)          # [1, 20, 3, 4, 5]
#-----------------------------------------------
my_list = [1, 2, 3, 4, 5]
my_list[1:3] = [20, 30]
print(my_list)          # [1, 20, 30, 4, 5]
my_list[1:3] = [0]      # нет проблем заменить два элемента на один
print(my_list)          # [1, 0, 4, 5]
my_list[2:] = [40, 50, 60]   # или два элемента на три
print(my_list)               # [1, 0, 40, 50, 60]

#Можно просто удалить часть последовательности

my_list = [1, 2, 3, 4, 5]
my_list[:2] = []    # или del my_list[:2]
print(my_list)      # [3, 4, 5]
#-----------------------------------------------
#Обращение к несуществующему индексу коллекции вызывает ошибку:

my_list = [1, 2, 3, 4, 5]
print(my_list[-10])       # IndexError: list index out of range
print(my_list[10])        # IndexError: list index out of range

#А в случае выхода границ среза за границы коллекции никакой ошибки не происходит:

my_list = [1, 2, 3, 4, 5]
print(my_list[0:10])      # [1, 2, 3, 4, 5] — отработали в пределах коллекции
print(my_list[10:100])	  # [] - таких элементов нет — вернули пустую коллекцию
print(my_list[10:11])     # [] - проверяем 1 отсутствующий элемент - пустая коллекция, без ошибки
#-----------------------------------------------
my_list = [2, 5, 1, 7, 3]
my_list_sorted = sorted(my_list)
print(my_list_sorted)       # [1, 2, 3, 5, 7]

my_set = {2, 5, 1, 7, 3}
my_set_sorted = sorted(my_set, reverse=True)
print(my_set_sorted)        # [7, 5, 3, 2, 1]
#-----------------------------------------------
my_files = ['somecat.jpg', 'pc.png', 'apple.bmp', 'mydog.gif']
my_files_sorted = sorted(my_files, key=len)
print(my_files_sorted)      # ['pc.png', 'apple.bmp', 'mydog.gif', 'somecat.jpg']
#-----------------------------------------------
my_list = [2, 5, 1, 7, 3]
my_list_sorted = reversed(my_list)
print(my_list_sorted)           # <listreverseiterator object at 0x7f8982121450>
print(list(my_list_sorted))     # [3, 7, 1, 5, 2]
print(my_list[::-1])            # [3, 7, 1, 5, 2] - тот же результат с помощью среза
#-----------------------------------------------
my_list = [2, 5, 1, 7, 3]
my_list.sort()
print(my_list)          # [1, 2, 3, 5, 7]

#-----------------------------------------------
my_list = [2, 5, 1, 7, 3]
my_list = my_list.sort()
print(my_list)          # None

#-----------------------------------------------
my_dict = {'a': 1, 'c': 3, 'e': 5, 'f': 6, 'b': 2, 'd': 4}
mysorted = sorted(my_dict)
print(mysorted)           # ['a', 'b', 'c', 'd', 'e', 'f']
mysorted = sorted(my_dict.items())
print(mysorted)           # [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]
mysorted = sorted(my_dict.values())
print(mysorted)           # [1, 2, 3, 4, 5, 6]

#-----------------------------------------------
population = {"Shanghai": 24256800, "Karachi": 23500000, "Beijing": 21516000, "Delhi": 16787941}
# отсортируем по возрастанию населения:
population_sorted = sorted(population.items(), key=lambda x: x[1])
print(population_sorted)
# [('Delhi', 16787941), ('Beijing', 21516000), ('Karachi', 23500000), ('Shanghai', 24256800)]
#-----------------------------------------------
shop = [('каретка', 1200), ('шатун', 1000), ('седло', 300),
        ('педаль', 100), ('седло', 1500), ('рама', 12000),
        ('обод', 2000), ('шатун', 200), ('седло', 2700)]
for det, price in shop:
    print('{:<10} цена: {:>5}р.'.format(det, price))

print('--------------------------------------')   

def prepare_item(item):
    return (item[0], -item[1])

# отсортировали по термину словаря
shop.sort(key=prepare_item)

for det, price in shop:
    print('{:<10} цена: {:>5}р.'.format(det, price))

print('--------------------------------------')   
def prepare_item(item):
    return (item[1])

# отсортировали по значению словаря
shop.sort(key=prepare_item)

for det, price in shop:
    print('{:<10} цена: {:>5}р.'.format(det, price))

#-----------------------------------------------
#-----------------------------------------------
#Чтобы не плодить утилитарные функции, вместо использования сторонней функции, того же эффекта можно добиться 
#с использованием лямбда-функции.
shop = [('каретка', 1200), ('шатун', 1000), ('седло', 200),
        ('педаль', 100), ('седло', 1500), ('рама', 12000),
        ('обод', 200), ('шатун', 200), ('седло', 2700)]

shop.sort(key=lambda x: x[0], reverse=True)
shop.sort(key=lambda x: (-x[1])) #shop.sort(key=lambda x: (x[0], -x[1]))

for det, price in shop:
    print('{:<10} цена: {:>5}р.'.format(det, price))
#-----------------------------------------------
str1 = 'abc'
str2 = 'de'
str3 = str1 + str2
print(str3)         # abcde

tuple1 = (1, 2, 3)
tuple2 = (4, 5)
tuple3 = tuple1 + tuple2
print(tuple3)       # (1, 2, 3, 4, 5)
#-----------------------------------------------
a = [1, 2, 3]
b = [4, 5]
c = a + b           
print(a, b, c)      # [1, 2, 3]  [4, 5]  [1, 2, 3, 4, 5]
#-----------------------------------------------
a = [1, 2, 3]
b = [4, 5]
c = a + [b]
print(a, b, c)     # [1, 2, 3]  [4, 5]  [1, 2, 3, [4, 5]]
#-----------------------------------------------
a, b = [1, 2, 3], [4, 5]
c = [*a, *b]  # работает на версии питона 3.5 и выше
print(c)      # [1, 2, 3, 4, 5]
#-----------------------------------------------
dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
dict3 = dict1.copy()
dict3.update(dict2)
print(dict3)        	# {'a': 1, 'c': 3, 'b': 2, 'd': 4}

#-----------------------------------------------
#В Питоне 3.5 появился новый более изящный способ:

dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
dict3 = {**dict1, **dict2}
print(dict3)        	# {'a': 1, 'c': 3, 'b': 2, 'd': 4}
#-----------------------------------------------
#Объединение (union):

c = a.union(b)     # c = b.union(a) даст такой же результат	
# c = a + b        # Обычное объединение оператором + не работает
		   # TypeError: unsupported operand type(s) for +: 'set' and 'set'
c = a | b          # Альтернативная форма записи объединения
print(c)	   # {'a', 'c', 'b'}
#-----------------------------------------------
#Пересечение (intersection):

c = a.intersection(b)    # c = b.intersection(a) даст такой же результат
c = a & b                # Альтернативная форма записи пересечения
print(c)                 # {'b'}

#Пересечение более 2-х множеств сразу:
a = {'a', 'b'}
b = {     'b', 'c'}
c = {    'b', 'd'}
d = a.intersection(b, c)	# Первый вариант записи
d = set.intersection(a, b, c)   # Второй вариант записи (более наглядный)
print(d)                        # {'b'}
#-----------------------------------------------
Разница (difference) — результат зависит от того, какое множество из какого вычитаем:

c = a.difference(b)      # c = a - b другой способ записи дающий тот же результат
print(c)                 # {'a'}
c = b.difference(a)      # c = b - a другой способ записи дающий тот же результат
print(c)                 # {'c'}
#-----------------------------------------------
#Симметричная разница (symmetric_difference) Это своего рода операция противоположная пересечению — 
#выбирает элементы из обеих множеств которые не пересекаются, то есть все кроме совпадающих:

c = b.symmetric_difference(a)   
# c = a.symmetric_difference(b)       # даст такой же результат
c = b ^ a                             # Альтернативная форма записи симметричной разницы
print(c)        		      # {'a', 'c'}
#-----------------------------------------------
a.extend(b)    # a += b эквивалентно a.extend(b)
print(a, b)    # [1, 2, 3, 4, 5]  [4, 5]
#-----------------------------------------------
#Добавляем все элементы второго списка к элементам первого с измением первого списка методом .extend():
a = [1, 2, 3]
b = [4, 5]
a.extend(b)    # a += b эквивалентно a.extend(b)
print(a, b)    # [1, 2, 3, 4, 5]  [4, 5]
#-----------------------------------------------
#Добавляем второй список как один элемент с изменением первого списка методом .append():
a = [1, 2, 3]
b = [4, 5]

a.append(b)    # a += [b] эквивалентно a.append(b)
print(a, b)    # [1, 2, 3, [4, 5]]  [4, 5]
#-----------------------------------------------
#Для изменения словаря с добавления элементов другого словаря используется метод .update().
#Обратите внимание: для совпадающих ключей словаря при этом обновляются значения:

dict1 = {'a': 1, 'b': 2}
dict2 = {'a': 100, 'c': 3, 'd': 4}
dict1.update(dict2)
print(dict1)        # {'a': 100, 'c': 3, 'b': 2, 'd': 4}
#-----------------------------------------------
#.difference_update()

a = {'a', 'b'}
b = {     'b', 'c'}
a.difference_update(b)
print(a, b)         # {'a'} {'b', 'c'}
a = {'a', 'b'}
b = {     'b', 'c'}
b.difference_update(a)
print(a, b)     
#-----------------------------------------------
#intersection_update()

a = {'a', 'b'}
b = {     'b', 'c'}
a.intersection_update(b)
print(a, b)         # {'b'} {'b', 'c'}

a = {'a', 'b'}
b = {     'b', 'c'}
b.intersection_update(a)
print(a, b)         # {'b', 'a'} {'b'}
#-----------------------------------------------
#.symmetric_difference_update()

a = {'a', 'b'}
b = {     'b', 'c'}
a.symmetric_difference_update(b)    
print(a, b)         # {'c', 'a'} {'c', 'b'}

a = {'a', 'b'}
b = {     'b', 'c'}
b.symmetric_difference_update(a)
print(a, b)         # {'a', 'b'} {'c', 'a'}
#-----------------------------------------------
Примеры использования метода .insert(index, element)
my_list = [1, 2, 3]
my_list.insert(0, 0)    # index = 0 - вставляем в начало
print(my_list)          # [0, 1, 2, 3]

my_list.insert(10, 4)   # Индекс выходит за границы списка -  просто добавим в конец
print(my_list)          # [0, 1, 2, 3, 4]

my_list.insert(-10, -1) # Индекс выходит за границы в минус - добавим в начало
print(my_list)          # [-1, 0, 1, 2, 3, 4]

my_list = [1, 2, 3]
my_list.insert(1, 1.5)  # Вставим между 1 и 2 (индексация с нуля!)
# То есть вставляется на позицию с указанным индексом, а то значение что на ней было 
# и те что правее - сдвигаются на 1 индекс вправо
print(my_list)          # [1, 1.5, 2, 3]
#-----------------------------------------------
#Строка неизменяемая коллекция — если мы ее меняем — мы создаем новый объект!

str1 = 'abc'
print(str1, id(str1))       # abc 140234080454000
str1 += 'de'
print(str1, id(str1))       # abcde 140234079974992 - Это НОВЫЙ объект, с другим id!
#-----------------------------------------------
#Пример кода с двумя исходно идентичными строками.

str1 = 'abc'
str2 = str1
print(str1 is str2)       # True - это две ссылки на один и тот же объект!
str1 += 'de'              # Теперь переменная str1 ссылается на другой объект!
print(str1 is str2)       # False - теперь это два разных объекта!
print(str1, str2)         # abcde abc - разные значения
#-----------------------------------------------
#Список изменяем и тут надо быть очень внимательным, чтобы не допустить серьезную ошибку! 
#Сравните данный пример с примером со строками выше:

list1 = [1, 2, 3]
list2 = list1
print(list1 is list2)     # True - это две ссылки на один и тот же объект!
# А дальше убеждаемся, насколько это важно:
list1 += [4]
print(list1, list2)       # [1, 2, 3, 4] [1, 2, 3, 4] 
# изменилось значение ОБЕИХ переменных, так как обе переменные ссылаются на один объект!
#-----------------------------------------------
#А если нужна независимая копия, с которой можно работать отдельно?

list1 = [1, 2, 3]
list2 = list(list1)       # Первый способ копирования
list3 = list1[:]          # Второй способ копирования
list4 = list1.copy()      # Третий способ копировани - только в Python 3.3+
print(id(list1), id(list2), id(list3), id(list4))      
# все 4 id разные, что значит что мы создали 4 разных объекта

list1 += [4]              # меняем исходный список
print(list1, list2, list3, list4)       # [1, 2, 3, 4] [1, 2, 3] [1, 2, 3] [1, 2, 3]  
# как мы и хотели - изменив исходный объект, его копии остались не тронутыми
#-----------------------------------------------

#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
#-----------------------------------------------
